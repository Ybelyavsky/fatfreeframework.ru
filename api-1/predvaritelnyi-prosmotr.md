# Предварительный просмотр



Предварительный просмотр-это легкий класс шаблонизатора, который расширяет класс представления.

Пространство имен: `\`  
Расположение файла: `lib/base.php`

### Визуализация шаблона предварительного просмотра <a id="render-a-preview-template"></a>

Класс Preview Template предлагает механизм чрезвычайно легкого шаблонирования, который просто вызывает некоторые php-выражения, завернутые в `{~ ~}`управляющие символы. Это полезно для любого типа стиля шаблона, такого как XML/HTML , [haml](https://z5h64q92x9.net/proxy_u/en-ru.ru/haml.info/)или что-то еще.

Давайте рассмотрим простой пример:

```text
<div>
	<h1>My favorite books</h1>
	<ul>
		{~ foreach (@books as @id=>@book): ~}
		<li>{~ if (@book.starred): ~}<i class="icon-star"></i>{~ else: ~}<i class="icon-normal">{~ endif ~}
			<a href="{{ @BASE.@book[slug] }}">{{ @book.title }}</a>
		</li>
		{~ endforeach ~}
	</ul>
</div>
```

### Методы <a id="methods"></a>

#### строить <a id="build"></a>

**Сборка разметки**

```text
string build ( string $node )
```

Этот метод строит php-код из заданной разметки, которая используется позже в предварительно отрисованном шаблоне. Информация об этом методе становится полезной при создании новых расширений шаблонов или пользовательских обработчиков тегов.

В Примере он преобразует этот кусок токена:

```text
{{ @book.title | esc }}
```

в:

```text
<?php echo $this->esc($book['title']); ?>
```

#### Фильтр <a id="filter"></a>

**Фильтр регистрационных токенов**

```text
mixed filter ( [ string $key = NULL [, string $func = NULL ] )
```

Вы можете использовать этот метод, чтобы добавить свой собственный шаблон token filter like `{{ @content | myfilter }}`. Например:

```text
\Preview::instance()->filter('badwords','\Helper::instance()->badwords');
```

```text
class Helper extends \Prefab {
	function badwords($val) {
		$bad_words = array("badword","jerk","damn");
		$replacement_words = array("@#$@#", "j&*%", "da*@"); 
		return str_ireplace($bad_words, $replacement_words, $val);
	}
}
```

Теперь вы можете использовать `{{ @user_comment | badwords }}user_comment`VAR для фильтрации плохих слов. Также можно комбинировать несколько фильтров: `{{ @user_comment | badwords, raw }}`.

Когда функция вызывается без какого-либо параметра, она просто возвращает массив всех зарегистрированных имен фильтров. Когда функция вызывается с `$key$func`параметром, но без него, она возвращает зарегистрированную строку функции.

#### оказывать <a id="render"></a>

**Визуализация и возврат шаблона заданного его именем файла**

```text
string render ( string $file [, string $mime = 'text/html' [, array $hive = NULL [, int $ttl = 0 ]]] )
```

`$file`Аргумент ожидает путь к файлу, который находится в пределах любых определенных каталогов системными переменными пользовательского интерфейса F3. Помните, что для вашего удобства [пользовательский](https://z5h64q92x9.net/proxy_u/en-ru.ru/https/fatfreeframework.com/3.7/quick-reference#ui) интерфейс может иметь несколько путей.

На самом деле метод рендеринга сначала пытается загрузить указанный шаблон из временной папки [TEMP](https://z5h64q92x9.net/proxy_u/en-ru.ru/https/fatfreeframework.com/3.7/quick-reference#temp), действующей в качестве файлового кэша для скомпилированных шаблонов. Указанный файл шаблона загружается только в случае необходимости: F3 достаточно умен, чтобы определить, была ли сохранена более новая версия файла шаблона, а затем он создает файл представления на основе php и только затем снова визуализирует представление php.

После визуализации F3 экранирует содержимое в соответствии с системной переменной ESCAPE и устанавливает соответствующее `Content-Type:`значение заголовка HTTP. Если вы хотите, чтобы ответ возвращался в виде JSON, XML или содержимого электронной почты, просто измените параметр `$mime`type в соответствии с вашими потребностями. \(В то время как кодировка содержимого определяется системной переменной кодирования\)

`$hive`Аргумент позволяет использовать явный массив переменных для этого шаблона. По умолчанию визуализированный шаблон имеет доступ ко всему улью F3 со всеми его переменными.

`$ttl`Аргумент указывает в секундах время жизни в кэше F3 для скомпилированного на основе php файла представления. Когда a `$ttl`будет задано, F3 сохранит скомпилированное представление в кэше. При следующем запросе, если заданное время `$ttl`прошло, скомпилированное представление будет перестроено из шаблона и снова сохранено в кэше для другого цикла.

Примеры:

```text
echo $tmpl->render('layout.html'); // assumes layout.html is in the UI folder
```

```text
$flow = $tmpl->render('widgets/tweeter-feeds.html', 'application/json', NULL, 300 ); // cache for 5 minutes
```

#### разрешить <a id="resolve"></a>

**Строка шаблона рендеринга**

```text
string resolve ( string $str [, array $hive = NULL ] )
```

Пример:

```text
$tmpl = \Preview::instance();
$f3->set('title','<b>F3 rocks</b>');
$content = '<p>{{ @title | esc }}</p>';
echo $tmpl->resolve($content);
// return: <p>&amp;lt;b&amp;gt;F3 rocks&lt;/b&amp;gt;</p>
```

#### знак <a id="token"></a>

**Преобразование токена в переменную**

```text
string token ( string $str )
```

Пример:

```text
echo $template->token ('My {{@color}} car looks nice');

// returns the string  'My $color car looks nice'
```


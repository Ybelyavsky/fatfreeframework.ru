# Маршрутизация

Наш [первый пример](https://fatfreeframework.ru/user-guide/start) было не так уж трудно проглотить, не так ли?   
Вставьте другой маршрут перед командой `$f3->run()`:

```text
$f3->route('GET /about',
    function() {
        echo 'Donations go to a local charity... us!';
    }
);
```

Вы же не хотите загромождать глобальное пространство имен именами функций?   
Fat-Free распознает различные способы сопоставления обработчиков маршрутов с классами и методами ООП:

```text
class WebPage {
    function display() {
        echo 'I cannot object to an object';
    }
}

$f3->route('GET /about','WebPage->display');
```

HTTP-запросы также могут быть перенаправлены в статические методы класса:

```text
$f3->route('GET /login','Controller\Auth::login');
```

> Застрял с ошибкой 404? Проверьте конфигурацию [вашего сервера](https://fatfreeframework.com/3.7/routing-engine#sample-apache-configuration).

### Маршруты и токены 

В качестве демонстрации мощного доменного языка fat-Free \(DSL\) вы можете указать один маршрут для обработки различных возможностей:

```text
$f3->route('GET /brew/@count',
    function($f3) {
        echo $f3->get('PARAMS.count').' bottles of beer on the wall.';
    }
);
```

Этот пример показывает, как мы можем указать токен `@count`для представления части URL-адреса. Фреймворк будет обслуживать любой URL-адрес запроса, соответствующий префиксу `/brew/`, например `/brew/99`,  `/brew/98` и т. д. Это будет отображать `"99 бутылок пива на стене"` и `"98 бутылок пива на стене"`,  соответственно. 

Fat-Free также будет принять приглашение на странице /самогон/небьющиеся. \(Ожидайте, что это покажет "небьющиеся бутылки пива на стене".\) Когда такой динамический маршрут задан, Fat-Free автоматически заполняет глобальную переменную массива `PARAMS` значением захваченных строк в URL-адресе. Вызов `$f3->get()` внутри функции обратного вызова извлекает значение переменной фреймворка. Вы, конечно, можете применить этот метод в своем коде как часть презентации или бизнес-логики. Но мы обсудим это более подробно позже.

Обратите внимание, что Fat-Free понимает точечную нотацию массива. Вместо этого в коде можно использовать обычную нотацию `PARAMS['count']`, которая подвержена ошибкам опечаток и несбалансированным фигурным скобкам. В представлениях и шаблонах фреймворк допускает `@PARAMS.count` .графическая нотация, которая несколько похожа на Javascript. \(Мы рассмотрим представления и шаблоны позже.\)

Вот еще один способ доступа к маркерам в шаблоне запросов:

```text
$f3->route('GET /brew/@count',
    function($f3,$params) {
        echo $params['count'].' bottles of beer on the wall.';
    }
);
```

Вы можете использовать звездочку \(`*`\), чтобы принять любой URL-адрес после маршрута `/brew` - если вас действительно не волнует остальная часть пути:

```text
$f3->route('GET /brew/*',
    function() {
        echo 'Enough beer! We always end up here.';
    }
);
```

_Важный момент для рассмотрения: вы получите обезжиренный \(и себя\) путаете, если у вас есть оба `GET /brew/@count` и `GET /brew/*`_ вместе в одном приложении. Используйте одно или другое. Другое дело: Fat-Free видит `GET /brew` как отдельный и отличный от маршрута сделать `GET /brew/@count`. Каждый из них может иметь различные обработчики маршрутов.

`Важно: все обработчики маршрутов автоматически передают экземпляр фреймворка и маркеры маршрута. Видеть здесь.` 

### Именованные Маршруты 

Когда вы определяете маршрут, вы можете присвоить ему имя. Используйте имя маршрута в своем коде и шаблонах вместо введенного url-адреса. Затем, если вам нужно изменить свои URL-адреса, чтобы угодить маркетинговым властелинам, вам нужно только сделать изменение там, где был определен маршрут. Имена маршрутов должны соответствовать правилам именования переменных php \(без точек, тире и дефисов\).

Давайте назовем маршрут:

```text
$f3->route('GET @beer_list: /beer', 'Beer->list');
```

Имя вставляется после глагола маршрута \(`GET` в этом примере\), предшествующего символу `@`, и отделяется от части URL двоеточием `:` символ. Вы можете вставить пробел после двоеточия, если это облегчает чтение вашего кода \(как показано здесь\).

Чтобы перенаправить посетителя на новый URL-адрес, вызовите именованный маршрут внутри метода `reroute()`, например:

```text
// именованный маршрут - это строковое значение
$f3->reroute('@beer_list'); // обратите внимание на одинарные кавычки
```

 Если вы используете токены в своем маршруте, F3 заменит эти токены их текущим значением. Если вы хотите изменить значение маркера перед вызовом reroute, передайте его в качестве 2-го аргумента:

```text
$f3->route('GET @beer_list: /beer/@country', 'Beer->bycountry');

// в качестве аргумента именованному маршруту передается набор пар ключ-значение
$f3->reroute('@beer_list(@country=Germany)');

// если в вашем маршруте требуется более одного токена
$f3->route('GET @beer_village_list: /beer/@country/@village', 'Beer->byvillage');
$f3->reroute('@beer_village_list(@country=Germany,@village=Rhine)');
```

Не забудьте указать `urlencode()` ваши аргументы, если у вас есть символы, которые не соответствуют рекомендациям RFC 1738 для хорошо сформированных URL-адресов.

### Именованные маршруты в шаблонах 

Чтобы получить доступ к именованному маршруту в шаблоне, можно передать имя маршрута в фильтр псевдонимов:

```text
<a href="{{ 'beer_list' | alias }}">view beer list</a>
```

Если вы хотите построить ссылку на именованный маршрут, содержащий маркеры, вы можете передать дополнительные параметры в фильтр псевдонимов:

```text
<a href="{{ 'beer_village_list', 'country=Germany,village=Rhine' | alias }}">view beer list from Rhine, Germany</a>
```

Это также работает с переменными, которые выглядят как  `{{ @name, 'a=5,b='.@id | alias }}`. Вам нужно только установить или перезаписать маркеры в именованных маршрутах, которые вам нужно изменить. Все остальные маркеры разрешаются автоматически, исходя из текущего маршрута.

Если вам нужно заменить маркеры подстановочных знаков в вашем маршруте \(т. е. `GET @complex:/resize/@format/*/sep/*)`, используйте числовой индекс, чтобы указать его новое значение, например: `{{'complex','format=20x20,2=foo/bar,3=baz.gif'|alias}}`.

Чтобы создать URL-адреса в коде контроллера, см. раздел [псевдоним](https://fatfreeframework.com/3.7/base#alias) и [методы](https://fatfreeframework.com/3.7/base#build) сборки.

### Динамические Веб-Сайты 

Подождите секунду - во всех предыдущих примерах мы никогда по-настоящему не создавали каталог на нашем жестком диске для хранения этих маршрутов. Короткий ответ: мы не должны этого делать. Все маршруты F3 являются виртуальными. Они не отражают нашу структуру папок на жестком диске. Если у вас есть программы или статические файлы \(изображения, CSS и т. д.\) которые не используют фреймворк - до тех пор, пока пути к этим файлам не конфликтуют с каким - либо маршрутом, определенным в вашем приложении-ваше программное обеспечение веб-сервера доставит их в браузер пользователя, если сервер настроен правильно.

**Встроенный веб-сервер PHP 5.4**   
Последняя стабильная версия PHP имеет свой собственный встроенный веб-сервер. Запустите его, используя следующую конфигурацию:

```text
php -S localhost:80 -t /var/www/
```

Приведенная выше команда начнет маршрутизацию всех запросов в web root `/var/www`. Если поступит входящий HTTP-запрос на файл или папку, PHP будет искать его в корне веб-сайта и отправлять в браузер, если он будет найден. В противном случае PHP загрузит индекс по `index.php` \(содержащий ваш код с поддержкой F3\).

**Пример Конфигурации Apache**   
Если вы используете Apache, убедитесь, что вы активировали модуль перезаписи URL-адресов \(mod\_rewrite\) в вашем apache.conf \(или httpd.conf\) файл. Вы также должны создать a .файл htaccess, содержащий следующее:

```text
RewriteEngine On

RewriteRule ^(app|dict|ns|tmp)\/|\.ini$ - [R=404]

RewriteCond %{REQUEST_FILENAME} !-l
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule .* index.php [L,QSA]
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]
```

Скрипт сообщает Apache, что всякий раз, когда приходит HTTP-запрос и если нет физического файла \(`!-f`\) или путь \(`!-d`\) или символическая ссылка \(`!-l`\) можно найти, он должен передать управление `index.php`, который содержит наш главный / передний контроллер, и который, в свою очередь, вызывает фреймворк.

То.файл `.htaccess`, содержащий указанные выше директивы Apache, всегда должен находиться в той же папке, что и `index.php`.

Вам также нужно настроить Apache, чтобы он знал физическое местоположение `index.php` на вашем жестком диске. Типичная конфигурация-это:

```text
DocumentRoot "/var/www/html"
<Directory "/var/www/html">
    Options -Indexes +FollowSymLinks +Includes
    AllowOverride All
    Order allow,deny
    Allow from All
</Directory>
```

Приказ разрешить, запретить Разрешить от всех &lt;/Справочник&gt; В случае, если вы просто помещаете свой обезжиренный проект в подпапку существующего корневого документа, некоторые конфигурации Apache, возможно, также нуждаются в определенной `RewriteBase` перезаписи .файл `.htaccess`. Если приложение не работает или маршрут по умолчанию `/` работает, но `/test`, возможно, не работает, попробуйте добавить базовый путь:

```text
RewriteEngine On
RewriteBase /fatfree-project/
```

Если вы разрабатываете несколько приложений одновременно, управлять конфигурацией виртуального хоста будет проще:

```text
NameVirtualHost *
<VirtualHost *>
    ServerName site1.com
    DocumentRoot "/var/www/site1"
    <Directory "/var/www/site1">
        Options -Indexes +FollowSymLinks +Includes
        AllowOverride All
        Order allow,deny
        Allow from All
    </Directory>
</VirtualHost>
<VirtualHost *>
    ServerName site2.com
    DocumentRoot "/var/www/site2"
    <Directory "/var/www/site2">
        Options -Indexes +FollowSymLinks +Includes
        AllowOverride All
        Order allow,deny
        Allow from All
    </Directory>
</VirtualHost>
```

Каждое `ServerName` \(`site1.com` и еще `site2.com` в нашем примере\) должен быть указан в вашем файле `/etc/hosts`. В Windows вы должны отредактировать `C:/WINDOWS/system32/drivers/etc/hosts` -да. Для осуществления изменений может потребоваться перезагрузка компьютера. Затем вы можете направить свой веб-браузер по указанному адресу `http://site1.com` или `http://site2.com` виртуальные хосты значительно облегчают развертывание ваших приложений.

**Альтернативная конфигурация Apache**   
Если `mod_rewrite` недоступен на вашем сервере или вы хотите немного повысить производительность, вы можете воспользоваться директивой [FallbackResource](https://httpd.apache.org/docs/2.4/mod/mod_dir.html#fallbackresource), доступной в Apache 2.4 и выше.

В таком случае просто добавьте следующую строку в свой список .файл `.htaccess` или в вашей конфигурации VirtualHost:

```text
FallbackResource /index.php
```

Если ваше веб-приложение работает в подпапке корневого сервера, не забудьте соответствующим образом изменить директиву:

```text
FallbackResource /fatfree-project/index.php
```

Обратите внимание: в настоящее время существует ошибка, которая пропускает директиву, когда запрашиваемый URI заканчивается .php и находится в корне приложения: [http://localhost/fatfree-project/foo.php](http://localhost/fatfree-project/foo.php) = &gt; ошибка 404 [http://localhost/fatfree-project/foo/bar.php](http://localhost/fatfree-project/foo/bar.php) = &gt; OK Пример Конфигурации Nginx Для серверов Nginx вот рекомендуемая конфигурация \(замените ip\_address: port настройками PHP FastCGI вашей среды\):

сервер { root /var / www / html; местоположение / { индекс индекса.индекс php.html-индекс.htm; try\_files $uri / index.php?$строка запроса; } местоположение ~ .РНР$ { fastcgi\_pass ip\_address:порт; индекс fastcgi\_index.РНР; fastcgi\_param имя script\_filename $document\_root$fastcgi\_script\_name будет; включить fastcgi\_params; } } Пример Конфигурации Документации Сервера конфигурационный файл lighttpd настраиваются аналогичным образом:

$HTTP \["хост"\] =~ "www.example.com$" { URL-адрес.переписать-один раз = \(" ^/\(.\*?\)\(\?.+\)?$"=&gt;"/индекс.php/$1?$2" \) сервер.обработчик ошибок-404 = " / index.РНР" } Пример конфигурации IIS Установите модуль перезаписи URL-адреса и соответствующую платформу .NET framework, соответствующую Вашей версии Windows. Затем создайте файл с именем web.config в корневом каталоге приложения со следующим содержимым:

&lt;?xml version=" 1.0 "encoding=" UTF-8"?&gt; &lt;конфигурация&gt; &lt;система.web-сервер&gt; &lt;переписывать&gt; &lt;правила&gt; &lt;имя правила=" приложение "stopProcessing= "true"&gt;  &lt;условия logicalGrouping= "MatchAll"&gt; &lt;добавить входные данные="{REQUEST\_FILENAME}" при="IsFile" параметром ignorecase="ложных" отменяет="истинной" /&gt; &lt;добавить входные данные="{REQUEST\_FILENAME}" при="IsDirectory" параметром ignorecase="ложных" отменяет="истинной" /&gt; &lt;/условия&gt; &lt;тип действия="перезаписи" URL-адрес="индекс.php "appendQueryString= "true" /&gt; &lt;/правило&gt; &lt;/правила&gt; &lt;/переписывать&gt; &lt;/система.web-сервер&gt; &lt;/конфигурация&gt; Изменение маршрута Так что давайте вернемся к кодированию. Вы можете объявить страницу устаревшей и перенаправить посетителей на другой сайт:

$f3 - &gt;redirect \('GET\|HEAD /obsoletepage', '/ newpage'\); а это то же самое, что и

$f3 - &gt;маршрут \('GET\|HEAD /obsoletepage', функция\($f3\) { $f3 - &gt;reroute \('/newpage'\); } \); Если кто-то попытается получить доступ к URL-адресу [http://www.example.com/obsoletepage](http://www.example.com/obsoletepage) используя HTTP GET или HEAD request, фреймворк перенаправляет пользователя на URL-адрес: [http://www.example.com/newpage](http://www.example.com/newpage) как показано в приведенном выше примере. Вы также можете перенаправить пользователя на другой сайт, например $f3 - &gt;reroute\('[http://www.anotherexample.org/](http://www.anotherexample.org/)'\);.

Перенаправление может быть особенно полезно, когда вам нужно выполнить некоторые работы по техническому обслуживанию на вашем сайте. У вас может быть обработчик маршрута, который информирует ваших посетителей о том, что ваш сайт находится в автономном режиме в течение короткого периода времени.

Http-редиректы незаменимы, но они также могут быть дорогостоящими. Насколько это возможно, воздержитесь от использования $f3-&gt;reroute\(\) для отправки пользователя на другую страницу того же веб-сайта, если вы можете направить поток вашего приложения, вызвав функцию или метод, который обрабатывает целевой маршрут. Однако этот подход не изменит URL-адрес в адресной строке веб-браузера пользователя. Если это не то поведение, которое вы хотите, и вам действительно нужно отправить пользователя на другую страницу, в таких случаях, как успешная отправка формы или после аутентификации пользователя, Fat-Free отправляет заголовок HTTP 302 Found. Для всех других попыток перенаправить на другую страницу или сайт фреймворк отправляет заголовок HTTP 301 Moved Permanently.

Запуск a 404 Во время выполнения Fat-Free автоматически генерирует ошибку HTTP 404 всякий раз, когда видит, что входящий HTTP-запрос не соответствует ни одному из маршрутов, определенных в вашем приложении. Однако бывают случаи, когда вам нужно вызвать его самостоятельно.

Возьмем, к примеру, маршрут, определенный как GET /dogs/@breed. Логика вашего приложения может включать поиск в базе данных и попытку получить запись, соответствующую значению @breed во входящем HTTP-запросе. Поскольку Fat-Free будет принимать любое значение после префикса /dogs/ из-за наличия токена @breed, отображение сообщения HTTP 404 Not Found программно становится необходимым, когда программа не находит никакого соответствия в нашей базе данных. Для этого используйте следующую команду:

$f3 - &gt; ошибка\(404\); Отдых: Передача Репрезентативного Состояния Архитектура Fat-Free основана на концепции, что HTTP URI представляют собой абстрактные веб-ресурсы \(не ограничиваясь HTML\), и каждый ресурс может перемещаться из одного состояния приложения в другое. По этой причине F3 не имеет никаких ограничений на то, как вы структурируете свое приложение. Если вы предпочитаете использовать шаблон Model-View-Controller, F3 может помочь вам разделить компоненты приложения, чтобы придерживаться этой парадигмы. С другой стороны, фреймворк также поддерживает шаблон представления ресурсов-методов, и его реализация более проста.

Вот пример интерфейса ReST:

элемент класса { функция сделать\(\) {} функциональный пост\(\) {} функция поставлена\(\) {} функция удалить\(\) {} }

$f3=require \('lib / base.на PHP'\); $f3 - &gt;карта \('/cart / @item', 'Item'\); $f3 - &gt;выполнить\(\); Метод Fat-Free $f3 - &gt;map \(\) предоставляет интерфейс ReST путем сопоставления HTTP-методов в маршрутах с эквивалентными методами объекта или класса PHP. Если ваше приложение получает входящий HTTP-запрос типа GET/cart / 123, Fat-Free автоматически передаст управление методу get\(\) объекта или класса. Аналогично, запрос POST /cart/123 будет перенаправлен в метод класса элементов post \(\).

Сопоставленные методы могут быть префиксированы с помощью переменной PREMAP.

Примечание: браузеры не реализуют методы HTTP PUT и DELETE в обычных HTML-формах. Эти и другие методы ReST \(HEAD и CONNECT\) доступны только через AJAX-вызовы на сервер. Однако они могут быть туннелированы через POST-запрос, установив параметр \_method в нужный http-глагол.

Если фреймворк получает метод HTTP, который не реализован классом,он генерирует ошибку HTTP 405 Method Not Allowed. Ф3 автоматически реагирует с соответствующими заголовками, параметры HTTP-запросов методом. Фреймворк не будет сопоставлять этот запрос классу.

Обратите внимание: если вы планируете построить целый REST API, вам, вероятно, нужно обойти возможность извлечения отдельных элементов, целых коллекций элементов и сохранения и обновления записей, которые не всегда вписываются в один класс или заданные методы HTTP. Всегда лучше планировать свой API, прежде чем приступать к кодированию. Вот очень хорошая и бесплатная электронная книга о дизайне веб-API от apigee, которая может быть полезна. Автопогрузчик F3 Fat-Free имеет возможность загружать классы только в то время, когда они вам нужны, поэтому они не поглощают больше памяти, чем требуется конкретному сегменту вашего приложения. И вам не нужно писать длинный список операторов include или require только для загрузки классов PHP, сохраненных в разных файлах и разных местах. Фреймворк может сделать это автоматически для вас. Просто сохраните файлы классов \(по одному классу на файл\) в папке \(например, "myclassfiles"\) и установите переменную autoload, указывающую на эту папку:

$f3 - &gt;set \('AUTOLOAD', ' myclassfiles/'\); Важно: имя класса и имя файла должны быть идентичны, чтобы фреймворк мог автоматически загружать ваш класс. Если ваш класс называется BarBaz, ваш файл должен быть назван BarBaz.РНР. Барбаз в нижнем регистре.php тоже будет работать. \(подробности см. ниже\).

Когда вы вызываете свой класс или метод с помощью $obj=new Barbaz;, Fat-Free Framework будет искать файл barbaz.php в пути\(путях\), указанном в переменной autoloader. Как только он найдет файл, он будет включать в себя использование команды require PHP. Вот как работает автоматическая загрузка.

Путь автоматической загрузки ищется из расположения вашего индекса.PHP-файл. Вы можете установить свою переменную AUTOLOAD, используя абсолютный путь, т. е. /var/www/mywebsite.com/ myclassfiles / или используя относительный путь, как видно из расположения вашего индекса.PHP-файл ../myclassfiles/, когда индекс.php находится в файле /var/www/mywebsite.com/.

Вы также можете иметь несколько путей автоматической загрузки. Если ваши классы разделены на разные папки, вы можете поручить фреймворку автоматически загружать соответствующий класс при вызове статического метода или при создании экземпляра объекта. Измените переменную AUTOLOAD, чтобы она указывала на несколько папок:

Ф3-&gt;набор $\('Автозагрузка','админ/Автозагрузка/; инструкция/загрузки/; по умолчанию/'\); Работа с пространствами имен AUTOLOAD позволяет иерархиям классов находиться в подпапках с аналогичными именами, поэтому, если вы хотите, чтобы фреймворк автоматически загружал класс пространства имен, который вызывается следующим образом:

Ф3-&gt;набор $\('Автозагрузка','Автозагрузка/'\); $obj=новые гаджеты\iPad; Вы можете создать иерархию папок, которая следует той же структуре. Предполагая, что /var/www в/HTML-код/ является веб-корень, затем F3 будет выглядеть для класса в /var/www в/HTML-код/Автозагрузка/гаджеты/аксессуары для iPad.РНР. Файл ipad.php должен иметь следующий минимальный код:

пространство имен гаджеты; класс iPad {} Помните: все названия каталогов в Fat-Free должны заканчиваться косой чертой. Вы можете назначить путь поиска для загрузчика следующим образом:

Ф3-&gt;набор $\('Автозагрузка','главная/;вспомогательный/'\); NB: пространства имен здесь, чтобы помочь вам организовать свой код. Если вы используете их, вы можете решить, делать это с помощью F3 autoloader или нет. Если вы используете автозагрузчик, вам нужно создать папку для каждого пространства имен. Если вы не используете автозагрузчик, вы можете хранить свои файлы так, как вам нравится, имея в виду, что вам нужно будет включить каждый из них вручную. Маршрутизация к классу пространства имен F3, будучи фреймворком, ориентированным на пространство имен, позволяет использовать метод в классе namespaced в качестве обработчика маршрута, и есть несколько способов сделать это. Вызов статического метода:

$f3 - &gt;set \('AUTOLOAD', ' classes/'\); $Ф3-&gt;маршруте\('получить\|пост /", " Главная\дом::показать\); Приведенный выше код вызовет метод static show \(\) класса Home в основном пространстве имен. Домашний класс должен быть сохранен в папке classes/main/home.php для того, чтобы он загружался автоматически.

Если вы предпочитаете работать с объектами:

$Ф3-&gt;маршруте\('получить\|пост /','Главная\Главная страница-&gt;показать\); будет создан экземпляр домашнего класса во время выполнения и после этого вызовет метод show \(\).

Обработка корпуса автопогрузчика


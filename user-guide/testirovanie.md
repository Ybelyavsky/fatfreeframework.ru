# Тестирование

### Пуленепробиваемый Код <a id="bullet-proof-code"></a>

Надежные приложения являются результатом всестороннего тестирования. Проверка того, что каждая часть вашей программы соответствует спецификациям и соответствует ожиданиям конечного пользователя, означает поиск ошибок и их исправление как можно раньше в цикле разработки приложения.

Если вы мало или совсем ничего не знаете о методиках модульного тестирования, вы, вероятно, внедряете фрагменты кода непосредственно в существующую программу. Это, конечно, означает, что вы должны удалить их, как только программа запущена. Оставшиеся фрагменты кода, плохой дизайн и неправильная реализация могут подкрасться как ошибки, когда вы развернете свое приложение позже.

F3 позволяет вам легко отлаживать программы не мешая вашим обычным мыслительным процессам. Фреймворк не требует от вас создания сложных классов ООП, тяжелых тестовых структур и навязчивых процедур.

Unit/блок \(или тестовое приспособление\) может быть функцией/методом или классом. Давайте рассмотрим простой пример:

```text
function hello() {
    return 'Привет, Мир';
}
```

Сохраните его в файле под названием `hello.php`. Теперь, как мы узнаем, что он действительно работает так, как ожидалось? Давайте создадим нашу процедуру тестирования:

```text
$f3=require(__DIR__.'/lib/base.php'); // путь к f3

// Установка
$test=new Test;
include('hello.php');

// Здесь начинаются тесты
$test->expect(
    is_callable('hello'),
    'hello() is a function'
);

// Другой текст
$hello=hello();
$test->expect(
    !empty($hello),
    'Something was returned'
);

// Этот тест должен быть успешным
$test->expect(
    is_string($hello),
    'Return value is a string'
);

// Этот тест обречен на провал
$test->expect(
    strlen($hello)==13,
    'String length is 13'
);

// Отображение результатов; не MVC, но давайте сделаем это просто
foreach ($test->results() as $result) {
    echo $result['text'].'<br>';
    if ($result['status'])
        echo 'Pass';
    else
        echo 'Fail ('.$result['source'].')';
    echo '<br>';
}
```

Сохраните его в файле под названием `test.php`. Таким образом, мы можем сохранить целостность `hello.php`.

Для каждого теста, который вы хотите запустить, вызовите `expect()` метод проверки  класса `Test`. `expect()` имеет 2 аргумента:

1. `test` это тест, который будет запущен. Это должен быть простой тест, который приведет к состоянию Pass или Fail. ex: `$i==1`
2. `text` текст, который будет отображаться для этого теста в результате,  например: "вход равен цифре 1".

Когда тесты выполняются, встроенный модуль F3 `Test` класс будет отслеживает результат каждого вызова `expect()` метода. Выход каждого из них `$test->expect()` сохраняется в многомерном массиве с именем `results` и ключами:

* `text` \(зеркальное отображение аргумента 2 из `expect()`\),
* `status` \(логическое значение, представляющее результат теста\),
* `source` \(имя файла / номер строки конкретного теста для помощи в отладке\)

В конце теста можно выполнить итерацию по этому многомерному массиву, распечатать текст теста, а затем вывести состояние теста \(`true` если тест прошел, `false` если тест не удался, и включите исходный файл и строку для отладки\)

Fat-Free дает вам свободу для показа результатов теста. Вы можете получить выходные данные в виде обычного текста или даже симпатичного HTML-шаблона, отрисовав файл шаблона, который взаимодействует с массивом $test-&gt;results \(\).

Итак, как мы запускаем наш модульный тест? Если вы сохранили `test.php` в корневой папке документа вы можете просто открыть свой браузер и указать адрес `http://localhost/test.php`. Вот и все, что от него требуется.

### Издевательские HTTP-запросы <a id="mocking-http-requests"></a>

F3 дает вам возможность имитировать HTTP-запросы из вашей PHP-программы, чтобы вы могли проверить поведение конкретного маршрута, точно так же, как если бы посетитель веб-сайта запросил эту страницу через браузер.

Вот простой макет запроса:

```text
$f3->set('QUIET',TRUE);  // не показывать вывод активного маршрута
$f3->mock('GET /test');  // установите маршрут, по которому будет работать f3
// запустите тесты с помощью expect (), как показано выше
// ...
$f3->set('QUIET',FALSE); // привести результаты тестирования будут показаны позже
$f3->clear('ERROR');     // очистить все ошибки
```

`Tip:` Если у вас есть маршрут, определенный с параметрами токена, например /test / @name, вы можете проверить этот маршрут, установив значение для токена в команде mock, и получить доступ к этому значению во время тестирования из массива params assoc F3

```text
$f3->mock('GET /test/steve');
$name = $f3->get('PARAMS["name"]');
$test->expect(
    $name =="steve",
    'Uri param "name" equals "steve"'
);
```

Чтобы имитировать запрос POST и отправить имитированную HTML форму:

```text
$f3->mock('POST /test', array('foo'=>'bar')); // передача значений формы с помощью массива assoc
```

`Tip:` При использовании макета, отображении результатов тестирования с помощью визуализированного шаблона или тестировании чего-либо в вашей базе данных вам необходимо включить настройки конфигурации для F3, чтобы он знал расположение ваших шаблонов, параметров БД и т. д.

### Ожидая худшего, что может случиться <a id="expecting-the-worst-that-can-happen"></a>

После того, как вы освоите тестирование самых маленьких блоков вашего приложения, вы можете перейти к более крупным компонентам, модулям и подсистемам - проверяя по пути, правильно ли части взаимодействуют друг с другом.

`Tip:` Если вы создаете отдельные тестовые файлы и вашим тестам требуется доступ к значениям конфигурации или доступу к БД, используйте директиву include once для файла, имеющего путь к f3 и значениям конфигурации, и вызывайте этот файл include из каждого отдельного тестового файла. Если вы включаете каждый тестовый файл в один тестовый пакетный файл, то функция "включить один раз" позволит легко протестировать отдельные классы и Ваше полное приложение.

Тестирование управляемых фрагментов кода приводит к созданию более надежных программ, которые работают так, как вы ожидаете, и вплетает процесс тестирования в ткань вашего цикла разработки.

Вопрос, который нужно задать себе: "проверил ли я все возможные сценарии? "Чаще всего те ситуации, которые не были приняты во внимание, являются вероятными причинами ошибок.

Модульное тестирование очень помогает минимизировать эти случаи. Даже несколько тестов на каждом приборе могут значительно уменьшить головные боли. С другой стороны, написание приложений без модульного тестирования вообще создает проблемы.


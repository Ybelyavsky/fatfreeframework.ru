# Тестирование

### Пуленепробиваемый Код <a id="bullet-proof-code"></a>

Надежные приложения являются результатом всестороннего тестирования. Проверка того, что каждая часть вашей программы соответствует спецификациям и соответствует ожиданиям конечного пользователя, означает поиск ошибок и их исправление как можно раньше в цикле разработки приложения.

Если вы мало или совсем ничего не знаете о методиках модульного тестирования, вы, вероятно, внедряете фрагменты кода непосредственно в существующую программу, чтобы помочь вам с отладкой. Это, конечно, означает, что вы должны удалить их, как только программа запущена. Оставшиеся фрагменты кода, плохой дизайн и неправильная реализация могут подкрасться как ошибки, когда вы развернете свое приложение позже.

F3 позволяет вам легко отлаживать программы-не мешая вашим обычным мыслительным процессам. Фреймворк не требует от вас создания сложных классов ООП, тяжелых тестовых структур и навязчивых процедур.

Блок \(или тестовое приспособление\) может быть функцией/методом или классом. Давайте рассмотрим простой пример:

```text
function hello() {
    return 'Hello, World';
}
```

Сохраните его в файле под названием `hello.php`. Теперь, как мы узнаем, что он действительно работает так, как ожидалось? Давайте создадим нашу процедуру тестирования:

```text
$f3=require(__DIR__.'/lib/base.php'); // path to f3

// Set up
$test=new Test;
include('hello.php');

// This is where the tests begin
$test->expect(
    is_callable('hello'),
    'hello() is a function'
);

// Another test
$hello=hello();
$test->expect(
    !empty($hello),
    'Something was returned'
);

// This test should succeed
$test->expect(
    is_string($hello),
    'Return value is a string'
);

// This test is bound to fail
$test->expect(
    strlen($hello)==13,
    'String length is 13'
);

// Display the results; not MVC but let's keep it simple
foreach ($test->results() as $result) {
    echo $result['text'].'<br>';
    if ($result['status'])
        echo 'Pass';
    else
        echo 'Fail ('.$result['source'].')';
    echo '<br>';
}
```

Сохраните его в файле под названием `test.php`. Таким образом, мы можем сохранить целостность `hello.php`.

Теперь вот мясо нашего процесса модульного тестирования.

Для каждого теста, который вы хотите запустить, вызовите `expect()` метод проведения `Test` класс. `expect()` имеет 2 аргумента:

1. `test` это тест, который будет запущен. Это должен быть простой тест, который приведет к состоянию Pass или Fail. экс: `$i==1`
2. `text` является ли текст, который будет отображаться для этого теста, когда отображаются результаты теста. например:"вход равен цифре 1".

Когда тесты выполняются, встроенный модуль F3 `Test` класс будет отслеживает результат каждого `expect()` вызов метода. Выход каждого из них `$test->expect()` вызов сохраняется в многомерном массиве с именем `results` с клавишами:

* `text` \(зеркальное отображение аргумента 2 из `expect()`\),
* `status` \(логическое значение, представляющее результат теста\),
* `source` \(имя файла / номер строки конкретного теста для помощи в отладке\)

В конце теста можно выполнить итерацию по этому многомерному массиву, распечатать текст теста, а затем вывести состояние теста \(`true` если тест прошел, `false` если тест не удался, и включите исходный файл и строку для отладки\)

Fat-Free дает вам свободу для показа результатов теста в любом случае вы хотите. Вы можете получить выходные данные в виде обычного текста или даже симпатичного HTML-шаблона, отрисовав файл шаблона, который взаимодействует с массивом $test-&gt;results \(\).

Итак, как мы запускаем наш модульный тест? Если вы сохранили `test.php` в корневой папке документа вы можете просто открыть свой браузер и указать адрес `http://localhost/test.php`. Вот и все, что от него требуется.

### Издевательские HTTP-запросы <a id="mocking-http-requests"></a>

F3 дает вам возможность имитировать HTTP-запросы из вашей PHP-программы, чтобы вы могли проверить поведение конкретного маршрута, точно так же, как если бы посетитель веб-сайта запросил эту страницу через браузер.

Вот простой макет запроса:

```text
$f3->set('QUIET',TRUE);  // do not show output of the active route
$f3->mock('GET /test');  // set the route that f3 will run
// run tests using expect() as shown above
// ...
$f3->set('QUIET',FALSE); // allow test results to be shown later
$f3->clear('ERROR');  // clear any errors
```

`Tip:` Если у вас есть маршрут, определенный с параметрами токена, например /test / @name, вы можете проверить этот маршрут, установив значение для токена в команде mock, и получить доступ к этому значению во время тестирования из массива params assoc F3

```text
$f3->mock('GET /test/steve');
$name = $f3->get('PARAMS["name"]');
$test->expect(
    $name =="steve",
    'Uri param "name" equals "steve"'
);
```

Чтобы имитировать запрос POST и отправить имитированную HTML форму:

```text
$f3->mock('POST /test', array('foo'=>'bar')); // pass in form values using assoc array
```

`Tip:` При использовании макета, отображении результатов тестирования с помощью визуализированного шаблона или тестировании чего-либо в вашей базе данных вам необходимо включить настройки конфигурации для F3, чтобы он знал расположение ваших шаблонов, параметров БД и т. д.

### Ожидая худшего, что может случиться <a id="expecting-the-worst-that-can-happen"></a>

После того, как вы освоите тестирование самых маленьких блоков вашего приложения, вы можете перейти к более крупным компонентам, модулям и подсистемам - проверяя по пути, правильно ли части взаимодействуют друг с другом.

`Tip:` Если вы создаете отдельные тестовые файлы и вашим тестам требуется доступ к значениям конфигурации или доступу к БД, используйте директиву include once для файла, имеющего путь к f3 и значениям конфигурации, и вызывайте этот файл include из каждого отдельного тестового файла. Если вы включаете каждый тестовый файл в один тестовый пакетный файл, то функция "включить один раз" позволит легко протестировать отдельные классы и Ваше полное приложение.

Тестирование управляемых фрагментов кода приводит к созданию более надежных программ, которые работают так, как вы ожидаете, и вплетает процесс тестирования в ткань вашего цикла разработки.

Вопрос, который нужно задать себе: "проверил ли я все возможные сценарии?"Чаще всего те ситуации, которые не были приняты во внимание, являются вероятными причинами ошибок.

Модульное тестирование очень помогает минимизировать эти случаи. Даже несколько тестов на каждом приборе могут значительно уменьшить головные боли. С другой стороны, написание приложений без модульного тестирования вообще создает проблемы.


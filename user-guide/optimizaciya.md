# Оптимизация

## Оптимизация <a id="optimization"></a>

### Кэш-Движок <a id="cache-engine"></a>

Кэширование статических веб-страниц-так что код в некоторых обработчиках маршрутов может быть пропущен, а шаблоны не должны быть повторно обработаны-это один из способов уменьшить рабочую нагрузку вашего веб-сервера, чтобы он мог сосредоточиться на других задачах. Вы можете активировать механизм кэша фреймворка, предоставив `$f3->route()`методу третий аргумент. Просто укажите количество секунд до истечения срока действия кэшированной веб-страницы:

```text
$f3->route('GET /my_page','App->method',60);
```

Вот как это работает. В этом примере, когда F3 обнаруживает, что URL-адрес `/my_page` при первом обращении он выполняет обработчик маршрута, представленный вторым аргументом, и сохраняет все выходные данные браузера во встроенном кэше фреймворка \(на стороне сервера\). Аналогичная инструкция автоматически отправляется в веб-браузер пользователя \(на стороне клиента\), так что вместо отправки идентичного запроса на сервер в течение 60-секундного периода браузер может просто получить страницу локально. Фреймворк использует кэш для совершенно другой цели-обслуживания кэшированных данных фреймворка другим пользователям, запрашивающим ту же веб-страницу в течение 60-секундного периода времени. Он пропускает выполнение обработчика маршрута и обслуживает ранее сохраненную страницу непосредственно с диска. Когда кто-то пытается получить доступ к тому же URL-адресу после истечения 60-секундного таймера, F3 обновит кэш новой копией.

Наиболее вероятными кандидатами на кэширование являются веб-страницы со статическими данными. Fat-Free не будет кэшировать веб-страницу по указанному URL-адресу, если третий аргумент в `$f3->route()`методе равен нулю или не указан. F3 соответствует спецификациям HTTP: кэшировать можно только запросы GET и HEAD.

Вот важный момент, который следует учитывать при разработке вашего приложения. Не кэшируйте веб-страницы, если вы не понимаете возможных нежелательных побочных эффектов кэша на стороне клиента. Убедитесь, что вы активируете кэширование на веб-страницах, которые не имеют никакого отношения к состоянию сеанса пользователя.

Например, вы спроектировали свой сайт таким образом, чтобы все ваши веб-страницы имели параметры меню:`"Home"`,`"About Us"`, и`"Login"`, отображаемые, когда пользователь не вошел в ваше приложение. Вы также хотите, чтобы параметры меню изменились на:`"Home"`,`"About Us"`, и`"Logout"`, как только пользователь вошел в систему. Если вы проинструктировали Fat-Free кэшировать содержимое `"About Us"`страницы \(которая включает в себя параметры меню\), он делает это и также отправляет ту же инструкцию HTTP-клиенту. Независимо от состояния сеанса пользователя, то есть вошедшего или вышедшего из системы, браузер пользователя сделает снимок страницы в том состоянии сеанса, в котором она находилась. Будущие запросы пользователя на получение `"About Us"` страница до истечения тайм-аута кэша будет отображать те же параметры меню, которые были доступны в то время, когда страница была первоначально сохранена. Теперь пользователь, возможно, уже вошел в систему, но параметры меню по-прежнему те же, как если бы такого события не произошло. Это не то поведение, которое мы хотим от нашего приложения.

Кроме того, при использовании включенных файлов в кэшированных файлах , например`require_once('../inc/account_header.php')`, используемые относительные пути больше не будут работать, так как кэшированные файлы не хранятся в исходном каталоге файлов. Вам нужно будет либо указать полный путь к включенным файлам; либо сказать F3, чтобы он хранил кэшированные файлы в каталоге, который может найти php; либо добавить путь, где хранятся кэшированные файлы, в путь включения php \(это можно сделать в php.ini-файл\).

Несколько указателей:

* Не кэшируйте динамические страницы. Совершенно очевидно, что вы не хотите кэшировать данные, которые часто меняются. Однако вы можете активировать кэширование на страницах, содержащих данные, обновляемые ежечасно, ежедневно или даже ежегодно.По соображениям безопасности фреймворк ограничивает использование механизма кэширования `GET`только HTTP-маршрутами. Он не будет кэшировать отправленные формы!Не активируйте кэш на веб-страницах, которые на первый взгляд выглядят статичными. В нашем примере содержимое "о нас" может быть статичным, но меню-нет.
* Активируйте кэширование на страницах, доступных только в одном состоянии сеанса. Если вы хотите кэшировать `"About Us"`страницу, убедитесь, что она доступна только тогда, когда пользователь не вошел в систему.
* Если у вас есть RAMdisk или быстрый твердотельный накопитель, настройте `CACHE`глобальную переменную так, чтобы она указывала на этот накопитель. Это заставит ваше приложение работать как гоночный автомобиль Формулы-1.

**Примечание:** не устанавливайте значение таймаута на очень долгий период, пока вы не будете готовы развернуть свое приложение, то есть состояние выпуска или производства. Изменения, внесенные в любой из ваших PHP-скриптов, могут не оказать ожидаемого эффекта на отображаемый вывод, если страница существует в кэше фреймворка и срок ее действия не истек. Если вы все-таки изменили программу, которая генерирует страницу, затронутую таймером кэша, и хотите, чтобы эти изменения вступили в силу немедленно, вам следует очистить кэш, удалив файлы в каталоге cache / \(или любом другом пути\). `CACHE` глобальная переменная указывает на\). F3 автоматически обновит кэш, если это необходимо. На стороне клиента вы мало что можете сделать, кроме как проинструктировать пользователя очистить кэш браузера или дождаться истечения срока действия кэша.

PHP должен быть правильно настроен для правильной работы кэш-движка F3. Часовой пояс вашей операционной системы должен быть синхронизирован с датой.настройка часового пояса в `php.ini`файле.

Подобно маршрутам, Fat-Free также позволяет кэшировать запросы к базе данных. Прирост скорости может быть весьма значительным, особенно при использовании на сложных SQL-операторах, которые включают поиск статических данных или содержимого базы данных, которое редко изменяется. Активация кэша запросов к базе данных, чтобы фреймворку не приходилось каждый раз повторно выполнять инструкции SQL, так же проста, как добавление 3-го аргумента в команду F3::sql - тайм-аут кэша. Например:

```text
$db->exec('SELECT * from sizes;',NULL,86400);
```

Если мы ожидаем, что результат этого запроса к базе `Small`данных будет всегда`Medium`, и `Large`в течение 24-часового периода, мы указываем `86400`секунды в качестве 2-го аргумента, чтобы Fat-Free не приходилось выполнять запрос более одного раза в день. Вместо этого фреймворк будет хранить результат в кэше, извлекать его из кэша каждый раз, когда запрос поступает в течение указанного 24-часового периода времени, и повторно выполнять запрос, когда истекает таймер.

Сопоставитель данных SQL также использует механизм кэша для оптимизации синхронизации структур таблиц с объектами, которые их представляют. Значение по умолчанию-`60`секунды. Если вы внесете какие-либо изменения в структуру таблицы в своем ядре СУБД, вам придется подождать истечения срока действия таймера кэша, прежде чем увидеть эффект в вашем приложении. Это поведение можно изменить, указав третий аргумент конструктору сопоставителя данных. Установите его на высокое значение, если вы не планируете вносить какие-либо дальнейшие изменения в структуру таблицы.

```text
$user=new DB\SQL\Mapper($db,'users',NULL,86400);
```

По умолчанию механизм кэширования Fat-Free отключен. Вы можете включить его и разрешить ему автоматически обнаруживать APC, WinCache или XCache. Если он не может найти подходящий бэкэнд, F3 будет использовать файловую систему, то `tmp/cache/`есть папку:

```text
$f3->set('CACHE',TRUE);
```

Отключить кэш так же просто, как:

```text
$f3->set('CACHE',FALSE);
```

Если вы хотите переопределить функцию автоматического обнаружения, вы можете сделать это - как в случае с memcached back-end, который также поддерживает F3:

```text
$f3->set('CACHE','memcache=localhost:11211');
```

Вы также можете использовать механизм кэша для хранения ваших собственных переменных. Эти переменные будут сохраняться между HTTP-запросами и оставаться в кэше до тех пор, пока движок не получит инструкции по их удалению. Чтобы сохранить значение в кэше:

```text
$f3->set('var','Я хочу, чтобы это значение было сохранено',90);
```

`$f3->set()` третий аргумент метода предписывает фреймворку сохранять переменную в кэше в течение 90 секунд. Если ваше приложение выдает a `$f3->get('var')`в течение этого периода, F3 автоматически извлекает значение из кэша. Подобным же образом `$f3->clear('var')`будет очищено значение как из кэша, так и из оперативной памяти. Если вы хотите определить, существует ли переменная в кэше, \`$f3 - &gt;exists \('var'\)\); возвращает одно из двух возможных значений: FALSE, если переданная рамочная переменная не существует в кэше, или целое число, представляющее время сохранения переменной \(Un\*x time in seconds, с точностью до микросекунды\).

### Сохранение Javascript и CSS на здоровом питании <a id="keeping-javascript-and-css-on-a-healthy-diet"></a>

Fat-Free также имеет компрессор Javascript и CSS, доступный в [веб-плагине](https://z5h64q92x9.net/proxy_u/en-ru.ru/https/fatfreeframework.com/3.7/web#minify). Он может объединить все ваши CSS-файлы в одну таблицу стилей и все ваши Javascript-файлы в один скрипт, чтобы резко сократить количество HTTP-запросов, необходимых веб-странице. Уменьшение количества HTTP-запросов к вашему веб-серверу приводит к более быстрой загрузке страниц и лучшему UX.

Чтобы внедрить это простое улучшение, вам сначала нужно подготовить свои HTML-шаблоны, чтобы воспользоваться этой функцией.

Для CSS, вы можете начать вот так:

```text
<link rel="stylesheet" type="text/css" href="/minify/css?files=typo.css,grid.css" />
```

И сделайте то же самое с вашими файлами Javascript:

```text
<script type="text/javascript" src="/minify/js?files=dialog.js,main.js"></script>
```

Конечно, нам нужно настроить маршрут, чтобы обработать необходимый вызов на компрессор Fat-Free CSS / Javascript:

```text
$f3->route('GET /minify/@type',
	function($f3, $args) {
		$path = $f3->get('UI').$args['type'].'/';
		$files = preg_replace('/(\.+\/)/','',$_GET['files']); // close potential hacking attempts  
		echo Web::instance()->minify($files, null, true, $path);
	},
	3600*24
);

// @type сделает переменную `PARAMS.type` базовой точкой для правильного пути
// убедитесь, что вы упорядочили свои файлы для минимизации в подпапки по типу, т. е. /ui/css/ /ui/js
// minify захватит каждый файл, указанный в параметре строки запроса с именем "файлы", и объединит в 1 вывод
// Сохраните уменьшенный файл в кэше F3 в течение 24 часов. в будущих запросах на этот маршрут будет использоваться кэшированная версия
```

**Внимание!** Вы должны убедиться, что `$_GET['files']`он очищен и не содержит `../`символов, которые потенциально могут вызвать проблему безопасности в вашем приложении. Это было исправлено в v3.5.2, но вам нужно справиться с этим самостоятельно в любой предыдущей версии.

И это все, что в нем есть! `minify()` считывает каждый файл \(`typo.css`и `grid.css`в нашем примере CSS, `dialog.js`и `main.js`в нашем примере Javascript\), удаляет все ненужные пробелы и комментарии, объединяет все связанные элементы в единый компонент веб-страницы и прикрепляет будущий срок годности, чтобы веб-браузер пользователя кэшировал данные и не попадал на сервер при каждом запросе url-адреса. Важно, чтобы `PARAMS.type`переменная база указывала правильный путь. В противном случае механизм перезаписи URL-адресов внутри компрессора не найдет файлы CSS/Javascript.

### Кэширование На Стороне Клиента <a id="client-side-caching"></a>

В наших примерах фреймворк отправляет будущую дату истечения срока действия в веб-браузер клиента, поэтому любой запрос на один и тот же файл CSS или Javascript будет использовать кэшированную версию из хранилища файлов локального компьютера пользователя. Когда запрос файла делается на веб-сервер, F3 проверяет, был ли маршрут \(в данном примере файлы CSS или Javascript\) уже кэширован. В приведенном выше примере minify указанный нами маршрут имеет период обновления кэша `3600`в секундах \(1 час\), равный 24 часам. Кроме того, если веб-браузер отправляет `If-Modified-Since` заголовок запроса и фреймворк видят, что кэш не изменился, F3 просто отправляет `HTTP 304 Not Modified`ответ, так что пропускная способность не тратится впустую и содержимое загружается быстрее. Без `If-Modified-Since`заголовка Fat-Free отправляет кэшированный файл, если он доступен. В противном случае код маршрута выполняется с каждым запросом.

Совет: Если вы не часто изменяете свои файлы Javascript/CSS \(как это было бы, если бы вы использовали библиотеку Javascript, такую как jQuery, MooTools, Dojo и т. д.\), подумайте о добавлении таймера Кэша к маршруту, ведущему к вашему обработчику JavaScript / CSS minify \(3-й аргумент F3::route \(\)\), чтобы Fat-Free не приходилось сжимать и объединять эти файлы каждый раз при получении запроса.

### Ускорение PHP кода <a id="php-code-acceleration"></a>

Хотите, чтобы ваш сайт работал еще быстрее? Fat-Free лучше всего работает с альтернативным PHP-кэшем \(APC\), XCache или WinCache. Эти расширения PHP повышают производительность вашего приложения за счет оптимизации ваших PHP-скриптов \(включая код фреймворка\).

### Дросселирование Полосы Пропускания <a id="bandwidth-throttling"></a>

Быстрое приложение, которое обрабатывает все HTTP-запросы и отвечает на них в кратчайшие сроки, не всегда является хорошей идеей - особенно если ваша пропускная способность ограничена или трафик на вашем веб-сайте особенно велик. Обслуживание страниц ASAP также делает ваше приложение уязвимым для атак типа "отказ в обслуживании" \(DOS\). F3 имеет функцию регулирования пропускной способности, которая позволяет вам контролировать скорость обслуживания ваших веб-страниц. Вы можете указать полосу пропускания, используемую при подаче запроса с такими определениями маршрута, как этот:

```text
$f3->route('GET /login','\Backoffice\Login->handler', 0, 64);
```

В этом примере фреймворк будет обслуживать запросы GET к / login с максимальной скоростью 64 Кб / с \(`64 * 1024` байт в секунду\).

Регулирование пропускной способности на уровне приложения может быть особенно полезно для страниц входа в систему. Медленное реагирование на словарные атаки является хорошим способом снижения такого рода риска для безопасности.

